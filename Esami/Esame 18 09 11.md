# Esame 11.9.18

**SpecificaStatiClasse** Mezzo

Stati: {ARIPOSO, INMARCIA, ATTESA, INTRASBORDO}

Variabili di stato ausiliarie: -

Stato iniziale:
   Stato statocorrente = Stato.ARIPOSO

**SpecificaTransizioniClasse** Mezzo

Transizione: ARiposo→InMarcia
   partenza()

Evento: Partenza

Condizione: -

Azione:
   pre: -
   post: -

Transizione: InMarcia→InMarcia
   carica(persone)/caricate() {dest: carica.getMittente()}

Evento: Carica(persone: Insieme(persone))

Condizione: -

Azione:
   pre: -
   post: nuovoevento == Caricate(){dest = carica.getMitt()} and for (persona: persone) <this, persona> in trasporta

Transizione: InMarcia→Attesa
   guasto()/accogliere(){dest: null}

Evento: Guasto

Azione:
   pre: -
   post: nuovoevento in broadcasting == accogliere()

Transizione: Attesa→InTrasbordo
   ok() {mitt: mezzo}/carica(persone) {dest: mezzo}

Evento: Ok

Azione:
   pre: -
   post: nuovoevento == Carica(persone escluso il pilota) {dest = mezzo} and for (persona: persone) <this, persona> !in trasporta and <this, pilota> in trasporta

Transizione: InTrasbordo→ARiposo
   caricate() {mitt: mezzo}

Evento: Caricate

Azione:
   pre: -
   post: -

**FineSpecifica**

**SegnaturaAttivitaComplesse**

AttivitaPrincipale(C: Carovana, n: intero) : ();

Esecuzione(C: Carovana) : ();

Analisi(C: Carovana): (percentuale: reale);

**SegnaturaAttivitaAtomiche**

Verifica(C: Carovana, n: intero): (ok: booleano);

Avvia(C: Carovana): ();

Calcola(C: Carovana): (percentuale: reale);

**SegnaturaSegnaliIO**

Errore(): ();

Report(percentuale: reale): ();

Attesa(): ();

**FineSegnatura**

```jsx
package Mezzo;
public abstract class Mezzo implements Listener {
	private String tipo;
	private HashSet<TipoLinkTrasporta> trasporta;
	private final int MIN_TRASPORTA = 1;
	
	public Mezzo(String t) {
		tipo = t;
		trasporta = new HashSet<TipoLinkTrasporta>();
	}
	public int quantiTrasporta() {return trasporta.size();}
	public String getTipo() {return tipo;}
	public void inserisciLinkTrasporta(TipoLinkTrasporta l) {
		if (l != null && l.getMezzo() == this) 
			ManagerTrasporta.inserisci(l);
	}
	public void eliminaLinkTrasporta(TipoLinkTrasporta l) {
		if (l != null && l.getMezzo() == this)
			ManagerTrasporta.elimina(l);
	}
	public Set<TipoLinkTrasporta> getLinkTrasporta() {
			if (quantiTrasporta() < MIN_TRASPORTA)
				throw new RuntimeException("violata cardinalità 1..*");
			return (HashSet<TipoLinkTrasporta>) trasporta.clone();
	}
	public void inserisciPerManagerTrasporta(ManagerTrasporta m) {
		if (m != null)
			trasporta.add(m.getLink());
	}
	public void eliminaPerManagerTrasporta(ManagerTrasporta m) {
		if (m != null)
			trasporta.remove(m.getLink());
	}
	
	public static enum Stato = {RIPOSO, MARCIA, ATTESA, TRASBORDO};
	Stato statocorrente = Stato.RIPOSO;
	public Stato getStato() {return statocorrente;}
	
	public void fired(Evento e) {
		TaskExecutor.getInstance().perform(new MezzoFired(this,e));
	}
}
```

```jsx
package Mezzo;
class MezzoFired implements Task {
	private boolean eseguita = false;
	private Mezzo mezzo;
	private Evento e;
	
	public MezzoFired(Mezzo m, Evento e) {
		mezzo = m;
		this.e = e;
	}
	public synchronized void run() {
		if (eseguita || e.getDestinatario() != null && e.getDestinatario() != mezzo) 
			return;
		eseguita = true;
		
		switch(mezzo.getStato()) {
			case RIPOSO:
				if (e.getClass() == Partenza.class)
					mezzo.statocorrente = Stato.MARCIA;
				break;
			case MARCIA:
				if (e.getClass() == Carica.class) {
					Carica c = (Carica) e;
					HashSet<Persona> persone = c.getPlayload();
					for (persona: persone) {
						mezzo.inserisciLinkTrasporta(new TipoLinkTrasporta(mezzo, persona));
					}
					Environment.aggiungiEvento(new Caricate(mezzo, c.getMittente());
				}
				else if (e.getClass() == Guasto.class) {
					Environment.aggiungiEvento(new Accogliere(mezzo, null));
					mezzo.statocorrente = Stato.ATTESA;
				}
				break;
			case ATTESA:
				if (e.getClass() == Ok.Class) {
					HashSet<Persona> persone;
					for (TipoLinkTrasporta link: mezzo.getLinkTrasporta()) {
						Persona p = link.getPersona();
						if (mezzo.getClass() == MezzoNonAutonomo.Class && 
						((MezzoNonAutonomo)mezzo).getLinkPilota().getPilota() == p) 
							continue;
						mezzo.eliminaLinkTrasporta(link);
						persone.add(p);
					}
					Environment.aggiungiEvento(new Carica(mezzo, e.getMittente(), persone);
					mezzo.statocorrente = Stato.TRASBORDO;
				}
				break;
			case TRASBORDO:
				if (e.getClass() == Caricate.class) 
					mezzo.statocorrente = Stato.RIPOSO;
				break;
			default: throw new RuntimeException("stato non riconosciuto");
		}
	}
	public synchronized boolean estEseguita() {return eseguita;}
}		
```

Associazione trasporta (responsabilità doppia, 1..1 ←-→ 1..*)

```jsx
public class TipoLinkTrasporta {
	private final Mezzo mezzo;
	private final Persona persona;
	
	public TipoLinkTrasporta(Mezzo m, Persona p) {
		if (m == null || p == null)
			throw new RuntimeException("link non valido");
		mezzo = m;
		persona = p;
	}
	public Mezzo getMezzo() {return mezzo;}
	public Persona getPersona() {return persona;}
	
	public boolean equals(Object o) {
		if (o != null && getClass().euqlas(o.getClass())) {
			TipoLinkTrasporta l = (TipoLinkTrasporta)o;
			return l.mezzo == mezzo && l.persona == persona;
		}
		return false;
	}
	public int hashCode() {return mezzo.hashCode() + persona.hashCode();}
}
```

```jsx
public final class ManagerTrasporta {
	private TipoLinkTrasporta link;
	private ManagerTrasporta(TipoLinkTrasporta ****l) {link = l;}
	public TipoLinkTrasporta getLink() {return link;}

	public static void inserisci(TipoLinkTrasporta l) {
		if (l != null && l.getPersona().quantiTrasporta() == 0) {
			ManagerTrasporta m = new ManagerTrasporta(l);
			l.getMezzo().inserisciPerManagerTrasporta(m);
			l.getPersona().inserisciPerManagerTrasporta(m);
		}
	}
	public static void elimina(TipoLinkTrasporta l) {
		if (l != null && l.getPersona().getLinkTrasporta().euqlas(l)) {
			ManagerTrasporta m = new ManagerTrasporta(l);
			l.getMezzo().eliminaPerManagerTrasporta(m);
			l.getPersona().eliminaPerManagerTrasporta(m);
		}
	}
}
```

```jsx
package MezzoAutonomo;
public class MezzoAutonomo extends Mezzo {
	private int ultimoCollaudo;
	
	public MezzoAutonomo(String t, int u) {
		super(t);
		ultimoCollaudo = u;
	}
	public void setUltimoCollaudo(int u) {ultimoCollaudo = u;}
	public int getUltimoCollaudo(int u) {return ultimoCollaudo;}
}
```

```jsx
package MezzoNonAutonomo;
public class MezzoNonAutonomo extends Mezzo {
	private TipoLinkPilota pilota;
	private final int MIN_PILOTA = 1;

	public MezzoNonAutonomo(String t) {super(t);}
	
	public int quantiPilota() {
		if (pilota == null) 
			return 0;
		return 1;
	}
	public void inserisciLinkPilota(TipoLinkPilota l) {
		if (l != null && l.getPilota() == this)
			ManagerPilota.inserisci(l);
	}
	public void eliminaLinkPilota(TipoLinkPilota l) {
		if (l != null && l.getPilota() == this)
			ManagerPilota.elimina(l);
	}
	public TipoLinkPilota getLinkPilota() {
		if (pilota == null)
			throw new RuntimeException("violata cardinalità 1..1");
		return pilota;
	}
	public void inserisciPerManagerPilota(ManagerPilota m) {
		if (m != null)
			pilota = m.getLink();
	}
	public void eliminaPerManagerPilota(ManagerPilota m) {
		if (m != null)
			pilota = null;
	}
}
```

Associazione pilota(responsabilità doppia, 1..1 ←-→ 1..1, con un attibuto)

```jsx
public class TipoLinkPilota {
	private final MezzoNonAutonomo mezzo;
	private final Persona pilota;
	private int numVolte;
	
	public TipoLinkPilota(MezzoNonAutonomo m, Persona p, int n) {
		if (m == null && p == null)
			throw new RuntimeException("link non valido");
		mezzo = m;
		pilota = p;
		numVolta = n;
	}
	public MezzoNonAutonomo getMezzo() {return mezzo;}
	public Persona getPilota() {return pilota;}
	public int getNumVolte() {return numVolte;}
	
	public boolean equals(Object o) {
		if (o != null && getClass().equals(o.getClass())) {
			TipoLinkPilota l = (TipoLinkPilota) o;
			return l.mezzo == mezzo && l.pilota == pilota;
		}
		return false;
	}
	public int hashCode() {return mezzo.hashCode() + pilota.hashCode();}
}
```

```jsx
public final class ManagerPilota {
	private TipoLinkPilota link;
	private ManagerPilota(TipoLinkPilota l) {link = l;}
	public TipoLinkPilota getLink() {return link;}
	
	public static void inserisci(TipoLinkPilota l) {
		if (l != null && l.getMezzo().quantiPilota() == 0 && l.getPilota().quantiPilota() == 0) {
			ManagerPilota m = new ManagerPilota(l);
			l.getMezzo().inserisciPerManagerPilota(m);
			l.getPilota().inserisciPerManagerPilota(m);
		}
	}
	public static void elimina(TipoLinkPilota l) {
		if (l != null && l.getMezzo().getLinkPilota().equals(l)) {
			ManagerPilota m = new ManagerPilota(l);
			l.getMezzo().eliminaPerManagerPilota(m);
			l.getPilota().eliminaPerManagerPilota(m);
		}
	}
}
```

```jsx
package attivita_complesse;
public class AttivitaPrincipale implements Runnable {
	private boolean eseguita = false;
	private Carovana C;
	private int n;
	
	public AttivitaPrincipale(Carovana C, int n) {
		this.C = C;
		this.n = n;
	}
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
	
		Verifica v = new Verifica(C, n);
		TaskExecutor.getInstance().perform(v);
		boolean ok = v.getResult();
		
		if (!ok) {
			SegnaliIO.errore();
			return;
		}
		Esecuzione ramo1 = new Esecuzione(C);
		Thread t1 = new Thread(ramo1);
		t1.start();
		Analisi ramo2 = new Analisi(C);
		Thread t2 = new Thread(ramo2);
		t2.start();
	
		try {
			t1.join();
			t2.join();
		} catch(InterruptedException e) {
			e.printStackTrace();
		}
		double percentuale = ramo2.getResult();
		SegnaliIO.report(percentuale);
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```

```jsx
package attivita_complesse;
public class Esecuzione implements Runnable {
	private boolean eseguita = false;
	private Carovana C;
	
	public Esecuzione(Carovana C) {this.C = C;}
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
		
		Avvia a = new Avvia(C);
		TaskExecutor.getInstance().perform(a);
		SegnaliIO.attesa();
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```

```jsx
package attivita_complesse;
public class Analisi implements Runnable {
	private boolean eseguita = false;
	private Carovana C;
	private double result;

	public Analisi(Carovana C) {this.C = C;}
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;

		Calcola c = new Calcola(C);
		TaskExecutor.getInstance().perform(c);
		result = c.getResult();
	}
	public synchronized boolean estEseguita() {return eseguita;}
	public synchronized double getResult() {
		if (!eseguita)
			throw new RuntimeException("attivita analisi non eseguita");
		return result;
	}
}
```