# Esame 10.9.19

**SpecificaStatiClasse** Vagone

Stati: {SOSTA, MOVIMENTO}

Variabili di stato ausiliarie: - 

Stato iniziale:
   statocorrente: Stato.SOSTA;

**SpecificaTransizioniClasse** Vagone

Transizione: Sosta → Movimento
   partenza()

Evento: Partenza

Condizione: -

Azione:
   pre: -
   post: -

Transizione: Movimento → Sosta
   arrivo()

Evento: Arrivo

Condizione: -

Azione:
   pre: -
   post: -

Transizione: Sosta → Sosta
   sposta(vagone)[this.getPrecedente() == null && this.getSuccessivo() == null]/arrivo() {mitt: this, dest: vagone}

Evento: Sposta(vagone: Vagone)

Condizione: this.getPrecedente() == null && this.getSuccessivo() == null

Azione:
   pre: -
   post: nuovoevento == Arrivo(dest = vagone)

Transizione: Sosta → Sosta
   arrivo()[this.getSuccessivo() == null]/libero() {dest: arrivo.getMittente()}

Evento: Arrivo

Condizione: this.getSuccessivo() == null

Azione:
   pre: -
   post: this e arrivo.getMittente() sono collegati da un tipoLinkCollegamento l, con l.getPrecedente() == this e l.getSuccessivo() == arrivo.getMittente()

Transizione: Sosta → Sosta
   arrivo()[this.getSuccessivo() ≠ null]occupato() {dest: arrivo.getMittente()}

Evento: Arrivo

Condizione: this.getSuccessivo ≠ null

Azione:
   pre: -
   post: -

**FineSpecifica**

**SegnaturaAttivitaComplesse**

AttivitaPrincipale(T: Treno, V: Insieme(Vagone)): ();

Formazione(T: Treno, V: Insieme(Vagone)): ();

Orario() : (orario: stringa);

**SegnaturaAttivitaAtomiche**

Verifica(V: Insieme(Vagone)) : (ok: booleano);

CalcolaArrivo(orariopartenza: stringa, tratta: stringa) : (orarioarrivo: stringa);

**SegnaturaSegnaliIO**

Errore(): ();

StampaArrivo(orarioarrivo: stringa): ();

Orario() : (orario: stringa);

Tratta(): (tratta: stringa);

**FineSegnatura**

```jsx
package Vagone;
public class Vagone implements Listener {
	private String codice;
	private TipoLinkConnessione precedente;
	private TipoLinkConnessione successivo;
	
	public Vagone(String c) {codice = c;}
	public String getCodice() {return codice;}
	public void inserisciLinkPrecedente(TipoLinkConnessione l) {
		if (l != null && l.getSuccessivo() == this)
			ManagerConnessione.inserisci(l);
	}
	public void eliminaLinkPrecedente(TipoLinkConnessione l) {
		if (l != null && l.getSuccessivo() == this)
			ManagerConnessione.elimina(l);
	}
	public TipoLinkConnessione getLinkPrecedente() {return precedente;}
	
	public void inserisciPrecedentePerManagerConnessione(ManagerConnessione m) {
		if (m != null)
			precedente = m.getLink();
	}
	public void eliminaPrecedentePerManagerConnessione(ManagerConnessione m) {
		if (m != null)
			precedente = null;
	}
	public void inserisciLinkSuccessivo(TipoLinkConnessione l) {
		if (l != null && l.getPrecedente() == this)
			ManagerConnessione.inserisci(l);
	}
	public void eliminaLinkSuccessivo(TipoLinkConnessione l) {
		if (l != null && l.getPrecedente() == this)
			ManagerConnessione.elimina(l);
	}
	public TipoLinkConnessione getLinkSuccessivo() {return successivo;}
	
	public void inserisciSuccessivoPerManagerConnessione(ManagerConnessione m) {
		if (m != null)
			successivo = m.getLink();
	}
	public void eliminaSuccessivoPerManagerConnessione(ManagerConnessione m) {
		if (m != null)
			successivo = null;
	}
	
	//gestione stato
	public static enum Stato = {SOSTA, MOVIMENTO};
	Stato statocorrente = STATO;
	public Stato getStato() {return statocorrente;}
	
	//gestione transizioni
	public void fired(Evento e) {
		TaskExecutor.getInstance().perform(new VagoneFired(this,e));
	}
}
```

```jsx
package Vagone;
class VagoneFired implements Task {
	private boolean eseguita = false;
	private Vagone vagone;
	private Evento e;
	
	public VagoneFired(Vagone v, Evento e) {
		vagone = v;
		this.e = e;
	}
	public synchronized void esegui() {
		if (eseguita || e.getDestinazione() != null && e.getDestinazione() != vagone)
			return;
		eseguita = true;
		
		switch(vagone.getStato()) {
			case SOSTA:
				if (e.getClass() == Partenza.class)
					vagone.statocorrente = Stato.MOVIMENTO;
				else if (e.getClass() == Sposta.class) {
					if (vagone.getPrecedente() == null && vagone.getSuccessivo() == null) {
						Sposta s = (Sposta) e;
						Arrivo a = new Arrivo(vagone, s.getPlayload());
						Environment.aggiungiEvento(a);
					}
				}
				else if (e.getClass() == Arrivo.class) {
					if (vagone.getSuccessivo() == null) {
						Libero l = new Libero(vagone, e.getMittente());
						Environment.aggiungiEvento(l);
					}
					else {
						Occupato o = new Occupato(vagone, e.getMittente());
						Environment.aggiungiEvento(o);
					}
				}
				else if (e.getClass() == Libero.class) 
					vagone.inserisciTipoLinkPrecedente(new TipoLinkConnessione(e.getMittente(), vagone);
				break;
			case MOVIMENTO:
				if (e.getClass() == Arrivo.class) 
					vagone.statocorrente = Stato.SOSTA;
				break;
			default: throw new RuntimeException("stato non riconosciuto");
		}
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```

```jsx
public class TipoLinkConnessione {
	private final Vagone precedente;
	private final Vagone successivo;
	
	public TipoLinkConnessione(Vagone p, Vagone s) {
		if (p == null || s == null)
			throw new RuntimeException("link non valido");
		precedente = p;
		successivo = s;
	}
	public Vagone getPrecedente() {return precedente;}
	public Vagone getSuccessivo() {return successivo;}

	public boolean equals(Object o) {
		if (o != null && getClass().equals(o.getClass()) {
			TipoLinkConnessione l = (TipoLinkConnessione)o;
			return l.precedente == precedente && l.successivo == successivo;
		}
		return false;
	}
	public int hashCode() {return precedente.hashCode() + successivo.hashCode();}
}
```

```jsx
public final class ManagerConnessione {
	private TipoLinkConnessione link;
	private ManagerConnessione(TipoLinkConnessione l) {link = l;}
	public TipoLinkConnessione getLink() {return link;}
	
	public static void inserisci(TipoLinkConnessione l) {
		if (l != null && l.getPrecedente().getLinkSuccessivo() == null &&
	 l.getSuccessivo().getLinkPrecedente()) {
			ManagerConnessione m = new ManagerConnessione(l);
			l.getPrecedente().inserisciSuccessivoPerManagerConnessione(m);
			l.getSuccessivo().inserisciPrecedentePerManagerConnessione(m);
		}
	}
	public static void elimina(TipoLinkConnessione l) {
		if (l != null && l.getPrecedente().getLinkSuccessivo().equals(l)) {
			ManagerConnessione m = new ManagerConnessione(l);
			l.getPrecedente().eliminaSuccessivoPerMAnagerConnessione(m);
			l.getSuccessivo().eliminaPrecedentePerManagerConnsessione(m);
		}
	}
}
```

```jsx
package attivita_complesse;
public class AttivitaPrincipale implements Runnable {
	private boolean eseguita = false;
	private Treno T;
	private HashSet<Vagone> V;

	public AttivitaPrincipale(Treno t, HashSet<Vagone> v) {
		T = t;
		V = v;
	}
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
		
		Verifica v = new Verifica(V);
		TaskExecutor.getInstance().perform(v);
		boolean ok = v.getResult();
		
		if (!ok) {
			SegnaliIO.errore();
			return;
		}
		Formazione ramo1 = new Formazione(T, V);
		Thread t1 = new Thread(ramo1);
		t1.start();
		Orario ramo2 = new Orario();
		Thread t2 = new Thread(ramo2);
		t2.start();
		try {
			t1.join();
			t2.join();
		} catch(InterruptedException e) {
			e.printStackTrace();
		}

		String orario = ramo2.getResult();
		SegnaliIO.stampaOrario(orario);
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```

```jsx
package attivita_complesse;
public class Formazione implements Runnable {
	private boolean eseguita = false;
	private Treno T;
	private HashSet<Vagone> V;
	
	public Formazione(Treno t, HashSet<Vagone> v) {
		T = t;
		V = v;
	}
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
		
		Forma f = new Forma(T, V);
		TaskExecutor.getInstance().perform(f);
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```

```jsx
package attivita_complesse;
public class Orario implements Runnable {
	private boolean eseguita = false;
	private String result;
		
	public Orario() {}
	public synchronized void run() {
		if (eseguita) return;
		eseguita = false;
		
		String orario = SegnaliIO.orario();
		String tratta = SegnaliIO.tratta();
		
		CalcoloArrivo ca = new CalcoloArrivo(orario, tratta);
		TaskExecutor.getInstance().perform(ca);
		result = ca.getResult();
	}
	public synchronized boolean estEseguita() {return eseguita;}
	public synchronized String getResult() {
		if (!eseguita)
			throw new RuntimeException("attivita orario non eseguita");
		return result;
	}
}		
```