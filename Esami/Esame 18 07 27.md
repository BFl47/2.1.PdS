# Esame 27.7.18

**SpecificaStatiClasse** Diffusore

Stati: {STANDBY, DIFFUSIONE, ATTESA}

Variabili di stato ausiliarie: \
&nbsp;&nbsp;&nbsp;&nbsp;   diffusoreScelto: Diffusore

Stato iniziale:\
&nbsp;&nbsp;&nbsp;&nbsp;   statocorrente: Stato.STANDBY\
&nbsp;&nbsp;&nbsp;&nbsp;   diffusoreScelto: -

**SpecificaTransizioniClasse** Diffusore

Transizione: Standby → Diffusione\
&nbsp;&nbsp;&nbsp;&nbsp;   diffondere(contenuto)[puòdiffondere]

Evento: Diffondere(contenuto: Audio || contenuto: Video)

Condizione: contenuto.getClass() == Audio && Diffusore.getClass() == DAudio || contenuto.getClass() == Video && Diffusore.getClass() == DVideo

Azione: \
&nbsp;&nbsp;&nbsp;&nbsp;   pre: -\
&nbsp;&nbsp;&nbsp;&nbsp;   post: -

Transizione: Standby → Attesa\
&nbsp;&nbsp;&nbsp;&nbsp;   diffondere(contenuto)[!puòdiffondere]/diffondere(contenuto){dest: this.scegliDiffusore()}

Evento: Diffondere(contenuto: Audio || contenuto: Video)

Condizione: contenuto.getClass() == Audio && Diffusore.getClass() ≠ DAudio || contenuto.getClass() == Video && Diffusore.getClass() ≠ DVideo

Azione:\
&nbsp;&nbsp;&nbsp;&nbsp;   pre: -\
&nbsp;&nbsp;&nbsp;&nbsp;   post: nuovoevento == Diffondere(contenuto) {dest = this.scegliDiffusore} and this.diffusorescelto == this.scegliDiffusore

Transizione: Diffusione → Standby\
&nbsp;&nbsp;&nbsp;&nbsp;   stop()

Evento: Stop

Condizione: -

Azione: \
&nbsp;&nbsp;&nbsp;&nbsp;   pre: -\
&nbsp;&nbsp;&nbsp;&nbsp;   post: -

Transizione: Attesa → Standby\
&nbsp;&nbsp;&nbsp;&nbsp;   stop()/ stop() {dest: diffusore.diffusorescelto}

Evento: Stop

Condizione: -

Azione: \
&nbsp;&nbsp;&nbsp;&nbsp;   pre: -\
&nbsp;&nbsp;&nbsp;&nbsp;   post: nuovoevento == Stop{dest = diffusore.diffusorescelto}

**FineSpecifica**

**SpecificaAttivita** Principale

Principale(I: Istallazione): ();

VariabiliProcesso\
&nbsp;&nbsp;&nbsp;&nbsp;I: Istallazione\
&nbsp;&nbsp;&nbsp;&nbsp;numMedio: double\
&nbsp;&nbsp;&nbsp;&nbsp;ok: boolean

InizioProcesso

Verifica(I): (ok);

if (!ok) {\
&nbsp;&nbsp;&nbsp;&nbsp;SegnaliIO.errore(): ();\
&nbsp;&nbsp;&nbsp;&nbsp;return;\
}

fork {\
&nbsp;&nbsp;&nbsp;&nbsp;Thread t1: Funzionamento(I): ();\
&nbsp;&nbsp;&nbsp;&nbsp;Thread t2: Analisi(I): ();\
}

join: t1, t2;

NumeroMedio(I): (numMedio);

SegnaliIO.invia(numMedio) : ();

FineProcesso

**SpecificaAttivita** Funzionamento 

Funzionamento(I: Istallazione): ();

VariabiliProcesso\
&nbsp;&nbsp;&nbsp;&nbsp;I: Istallazione

InizioProcesso

Avvia(I): ();
SegnaliIO.Attesa(): ();

FineProcesso

**SpecificaAttivita** Analisi

Analisi(I: Istallazione): (num);

VariabiliProcesso\
&nbsp;&nbsp;&nbsp;&nbsp;I: Istallazione\
&nbsp;&nbsp;&nbsp;&nbsp;num: double

InizioProcesso

Calcola(I): (num);

SegnaliIO.invia(num): ();

FineProcesso

**FineSpecifica**

 

```jsx
package Diffusore;
public abstract class Diffusore implements Runnable {
	private String nome;
	private TipoLinkCostituita costituita;
	private TipoLinkMaster master;
		
	private final int MIN_COSTITUITA = 1;
	private final int MIN_MASTER = 1;
	
	public Diffusore(String n) {nome = n;}
	public int quantiCostituita() {
		if (costituita == null) return 0;
		return 1;
	}
	public int quantiMaster() {
		if (master == null) return 0;
		return 1;
	}
	public String getNome() {return nome;}
	public void inserisciLinkCostituita(TipoLinkCostituita l) {
		if (l != null && l.getDiffusore() == this)
			ManagerCostituita.inserisci(l);
	}
	public void eliminaLinkCostituita(TipoLinkCostituita l) {
		if (l != null && l.getDiffusore() == this)
			ManagerCostituita.elimina(l);
	}
	public TipoLinkCostituita getLinkCostituita() {
		if (costituita == null)
			throw new RuntimeException("violata cardinalià 1..1");
		return costituita;
	}
	public void inserisciPerManagerCostituita(ManagerCostituita m) {
		if (m != null)
			costituita = m.getLink();
	}
	public void eliminaPerManagerCostituita(ManagerCostituita m) {
		if (m != null)
			costituita = null();
	}
	public void inserisciLinkMaster(TipoLinkMaster l) {
		if (l != null && l.getDiffusore() == this)
			ManagerMaster.inserisci(l);
	}
	public void eliminaLinkMaster(TipoLinkMaster l) {
		if (l != null && l.getDiffusore() == this)
			ManagerMaster.elimina(l);
	}
	public TipoLinkMaster getLinkMaster() {
		if (master== null)
			throw new RuntimeException("violata cardinalià 1..1");
		return master;
	}
	public void inserisciPerManagerMaster(ManagerMaster m) {
		if (m != null)
			master= m.getLink();
	}
	public void eliminaPerManagerMaster(ManagerMaster m) {
		if (m != null)
			master = null();
	}
	
	public static enum Stato = {STANDBY, DIFFUSIONE, ATTESA};
	Stato statocorrente = Stato.STANDBY;
	Diffusore scelto;
	public Stato getStato() {return stato;}

	public void fired(Evento e) {
		TaskExecutor.getInstance().perform(new DiffusoreFired(this, e));
	}

	public Diffusore scegliDiffusore() {
		...
	}
```

```jsx
package Diffusore;
class DiffusoreFired implements Task {
	private boolean eseguita = false;
	private Diffusore diffusore;
	private Evento e;
	
	public DiffusoreFired(Diffusore d, Evento e){
		diffusore = d;
		this.e = e;
	}
	public synchronized void esegui() {
		if (eseguita || e.getDestinatario != null && e.getDestinatario != diffusore)
			return;
		eseguita = true;
		
		switch(diffusore.getStato()) {
			case STANDBY:
				if (e.getClass() == Diffondere.class) {
					Diffondere d = (Diffondere)e;
					if (d.getPlayload() == Video.class && diffusore.getClass() == DVideo.class ||
							d.getPlayload() == Audio.class && diffusore.getClass() == DAudio.class) 
						diffusore.statocorrente = Stato.DIFFUSIONE;
					else {
						diffusore.scelto = diffusore.scegliDiffusore();
						Environment.aggiungiEvento(new Diffondere(diffusore, diffusore.scelto));
						diffusore.statocorrente = Stato.ATTESA;
					}
				}
				break;
			case DIFFUSIONE:
				if (e.getClass() == Stop.class) 
					diffusore.statocorrente = Stato.STANDBY;
				break;
			case ATTESA:
				if (e.getClass() == Stop.class) {
					Environment.aggiungiEvento(new Stop(diffusore, diffusore.scelto));
					diffusore.statocorrente = Stato.STANDBY;
				}
				break;
			default: throw new RuntimeException("stato non riconosciuto");
		}
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```

```jsx
package DAudio;
public class DAudio extends Diffusore {
	private int watt;
	
	public DAudio(String n, int w) {
		super(n);
		watt = w;
	}
	public int getWatt() {return watt;}
}
```

```jsx
package DVideo;
public class DVideo extends Diffusore {
	private double pollici;
	
	public DVideo(STring n, double p) {
		super(n);
		pollici = p;
	}
	public double getPollici() {return pollici;}
}
```

Associazione Costituita (responsabilità doppia, 1..1 ←-→ 1..*)

```jsx
public class TipoLinkCostituita {
	private final Rete rete;
	private final Diffusore diffusore;
	
	public TipoLinkCostituita(Rete r, Diffusore d) {
		if (r == null || d == null)
			throw new RuntimeException("link non valido");
		rete = r;
		diffusore = d;
	}
	public Rete getRete() {return rete;}
	public Diffusore getDiffusore() {return diffusore;}
	
	public boolean equals(Object o) {
		if (o != null && getClass().equals(o.getClass())) {
			TipoLinkCostituita l = (TipoLinkCostituita) o;
			return l.rete == rete && l.diffusore == diffusore;
		}
		return false;
	}
	public int hashCode() {return rete.hashCode() + diffusore.hashCode();}
}
```

```jsx
public final class ManagerCostituita {
	private TipoLinkCostituita link;
	private ManagerCostituita(TipoLinkCostituita l) {link = l;}
	public TipoLinkCostituita getLink() {return link;}
	
	public static void inserisci(TipoLinkCostituita l) {
		if (l != null && l.getDiffusore().quantiCostituita() == 0) {
			ManagerCostituita m = new ManagerCostituita(l);
			l.getRete().inserisciPerManagerCostituita(m);
			l.getDiffusore().inserisciPerManagerCostituita(m);
		}
	}
	public static void elimina(TipoLinkCostituita l) {
		if (l != null && l.getDiffusore().getLinkCostituita().equals(l)) {
			ManagerCostituita m = new ManagerCostituita(l);
			l.getRete().eliminaPerManagerCostituita(m);
			l.getDiffusore().eliminaPerManagerCostituita(m);
		}
	}
}
```

```jsx
package attivita_complesse;
public class Principale implements Runnable {
	private boolean eseguita = false;
	private Istallazione I;

	public Principale(Istallazione I) {this.I = I;}
	
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
	
		Verifica v = new Verifica(I);
		TaskExecutor.getInstance().perform(v);
		boolean ok = v.getResult();
	
		Funzionamento ramo1 = new Funzionamento(I);
		Thread t1 = new Thread(ramo1);
		t1.start();
		Analisi ramo2 = new Analisi(I);
		Thread t2 = new Thread(ramo2);
		t2.start();
	
		try {
			t1.join();
			t2.join();
		} catch(InterruptedExceptione e) {
			e.printStackTrace();
		}
		NumeroMedio nm = new NumeroMedio(I);
		TaskExecutor.getInstence().perform(nm);
		double numMedio = nm.getResult();
		SegnaliIO.invia(numMedio);
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```

```jsx
package attivita_complessa;
public class Funzionamento implements Runnable {
	private boolean eseguita = false;
	private Istallazione I;
	
	public Funzionamento(Istallazione I) {this.I = I;}
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
	
		Avvia a = new Avvia(I);
		TaskExecutor.getInstance().perform(a);
		SegnaliIO.attesa();
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```

```jsx
package attivita_complessa;
public class Analisi implements Runnable {
	private boolean eseguita = false;
	private Istallazione I;

	public Analisi(Istallazione I) {this.I = I;}
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
		
		Calcola c = new Calcola(I);
		TaskExecutor.getInstance().perform(c);
		String report = c.getResult();
		SegnaliIO.report(report);
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```
