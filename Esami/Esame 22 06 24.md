# Esame 24.6.22

**SpecificaStatiClasse** Macchinario

Stato: {Riposo, InFunzione, Rotto}

Variabili di stato ausiliarie:\
&nbsp;&nbsp;&nbsp;&nbsp;   processo: Processo

Statoiniziale:\
&nbsp;&nbsp;&nbsp;&nbsp;   statocorrente = Riposo

**SpecificaTransizioniClasse** Macchinario

Transizione: Riposo→InFunzione\
&nbsp;&nbsp;&nbsp;&nbsp;   avvio(processo)/notificaAvvio(){mitt: this, dest: operatori}

Evento: Avvio(processo: Processo)

Condizione: -

Azione: \
&nbsp;&nbsp;&nbsp;&nbsp;   pre: -\
&nbsp;&nbsp;&nbsp;&nbsp;   post: se this.getClass() == ConUmano.class allora nuovoevento == NotificaAvvio() {mitt = this, dest = tutti gli operatori} and this.p == processo

Transizione: InFunzione → Riposo\
&nbsp;&nbsp;&nbsp;&nbsp;   completamento()

Evento: Completamento

Condizione: -

Azione:\
&nbsp;&nbsp;&nbsp;&nbsp;   pre: -\
&nbsp;&nbsp;&nbsp;&nbsp;   post: -

Transizione: InFunzione → Rotto\
&nbsp;&nbsp;&nbsp;&nbsp;   rottura()/notificaRottura() {mitt: this, dest: supervisore}

Evento: Rottura

Condizione: -

Azione:\
&nbsp;&nbsp;&nbsp;&nbsp;   pre: -\
&nbsp;&nbsp;&nbsp;&nbsp;   post: nuovoevento == NotificaRottura() {mitt = this, dest: processo.getLinkSupervisiona().getSupervisore()}

Transizione: Rotto → Riposo\
&nbsp;&nbsp;&nbsp;&nbsp;   manutenzione()

Evento: Manutenzione

Condizione: -

Azione: \
&nbsp;&nbsp;&nbsp;&nbsp;   pre: -\
&nbsp;&nbsp;&nbsp;&nbsp;   post: -

**FineSpecifica**

**SegnaturaAttivitaComplesse**

Principale(S: Supervisore): ();

UtilizzoMacchinario(m: Macchinario): (continua: booleano);

RaccoltaStatistiche(m: Macchinario): (report: stringa);

**SegnaturaAttivitaAtomiche**

Verifica(m: Macchinario): (ok: booleano);

AvviaMacchinario(m: Macchinario): ();

Raccolta(m: Macchinario): (report: stringa);

**SegnaturaSegnaliIO**

SceltaProcesso(): (processo: Processo);

Errore(): ();

Report(insieme_report: Lista(Stringa)): ();

**FineSegnatura**

 

```jsx
package Macchinario;
public abstract class Macchinario implements Listener {
	private String seriale;
	private String marca;
	private String modello;
	private Data acquisto;
	private Data manutenzione;
//suppongo ci sia una classe data con tre campi int: giorno, mese, anno
	private HashSet<TipoLinkPartecipa> partecipa;
	
	public Macchinario(String s, String ma, String mo, Data a) {
		seriale = s;
		marca = ma;
		modello = mo;
		acquisto = a;
		partecipa = new HashSet<TipoLinkPartecipa>();
	}
	public String getSeriale() {return seriale;}
	public String getMarca() {return marca;}
	public String getModello() {return modello;}
	public int getDataAcquisto() {return acquisto;}
	public int getDataManutenzione() {return manutenzione;}
	public void setDataManutenzione(Data m) {manutenzione = m;}

	public static Data dataOdierna() {...}
	
	//gestione associazione partecipa
	public void inserisciLinkPartecipa(TipoLinkPartecipa l) {
		if (l != null && l.getMacchinario() == this)
			ManagerPartecipa.inserisci(l);
	}
	public void eliminaLinkPartecipa(TipoLinkPartecipa l) {
		if (l != null && l.getMacchinario() == this)
			ManagerPartecipa.elimina(l);
	}
	public Set<TipoLinkPartecipa> getLinkPartecipa() {
		return(HashSet<TipoLinkPartecipa>) partecipa.clone();
	}
	public void inserisciPerManagerPartecipa(ManagerPartecipa m) {
		if (m != null)
			partecipa.add(m.getLink());
	}
	public void eliminaPErManagerPartecipa(ManagerPartecipa m) {
		if (m != null)
			partecipa.remove(m.getLink());
	}
	
	//gestione stato
	public static enum Stato = {RIPOSO, INFUNZIONE, ROTTO};
	Stato statocorrente = Stato.RIPOSO;
	Processo p;
	public Stato getStato() {return statocorrente;}

	//gestione transizioni
	public void fired(Evento e) {
		TaskExecutor.getInstance().perform(new MacchinarioFired(this, e));
	}
```

```jsx
package Macchinario;
class MacchinarioFired implements Task {
	private boolean eseguita = false;
	private Macchinario macchinario;
	private Evento e;
	
	public MacchinarioFired(Macchinario m, Evento e) {
		macchinario = m;
		this.e = e;
	}
	public synchronized void esegui() {
		if (eseguita || e.getDestinatario() != null && e.getDestinatario() != macchinario) 
			return;
		eseguita = true;
		
		switch(macchinario.getStato()) {
			case RIPOSO:
				if (e.getClass() == Avvio.class) {
					Avvio a = (Avvio) e;
					macchinario.p = a.getPlayload();
					if (macchinario.getClass() == ConUmano.class) {
						ConUmano conum = (ConUmano) macchinario;
						for (TipoLinkAssegnato l: conum.getLinkAssegnato())
							Environment.nuovoEvento(new NotificaAvvio(macchinario, l.getOperatore()));
					}
					macchinario.statocorrente = Stato.INFUNZIONE;
				}
				break;
			case INFUNZIONE:
				if (e.getClass() == Completamento.class) 
					macchinario.statocorrente = Stato.RIPOSO;
				else if (e.getClass() == Rottura.class) {
					Environment.nuovoEvento(new NotificaRottura
			(macchinario, macchinario.p.getLinkSupervisiona().getSupervisore()));
					macchinario.statocorrente = Stato.ROTTO;
				}
				break;
			case ROTTO:
				if (e.getClass() == Manutenzione.class) {
					macchinario.setDataManutenzione(Macchinario.dataOdierna());
					macchinario.statocorrente = Stato.RIPOSO;
				}
				break;
			default: throw new RuntimeException("stato non riconosciuto");
		}
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```

Associazione partecipa (responsabilità doppia, 2..* ←→ 0..*, senza attributi)

```jsx
public class TipoLinkPartecipa {
	private final Macchinario macchinario;
	private final Processo processo;
	
	public TipoLinkPartecipa(Macchinario m, Processo p) {
		if (m == null || p == null)
			throw new RuntimeException("link non valido");
		macchinario = m;
		processo = p;
	}
	public Macchinario getMacchinario() {return macchinario;}
	public Processo getProcesso() {return processo;}
	
	public boolean equals(Object o) {
		if (o != null && getClass().equals(o.getClass()) {
			TipoLinkPartecipa l = (TipoLinkPartecipa)o;
			return l.macchinario == macchinario && l.processo == processo;
		}
		return false;
	}
	public int hashCode() {return macchinario.hashCode() + processo.hashCode();}
}
```

```jsx
public final class ManagerPartecipa {
	private TipoLinkPartecipa link;
	private ManagerPartecipa(TipoLinkPartecipa l) {link = l;}
	public TipoLinkPartecipa getLink() {return link;}

	public static void inserisci(TipoLinkPartecipa l) {
		if (l != null) {
			ManagerPartecipa m = new ManagerPartecipa(l);
			l.getMacchinario().inserisciPerMAnagerPartecipa(m);
			l.getProcesso().inserisciPerManagerPartecipa(m);
		}
	}
	public static void elimina(TipoLinkPartecipa l) {
		if (l != null) {
			ManagerPartecipa m = new ManagerPartecipa(l);
			l.getMacchinario().eliminaPerManagerPartecipa(m);
			l.getProcesso().eliminaPerManagerPartecipa(m);
		}
	}
}
```

```jsx
package ConUmano;
import Macchinario.*;
public class ConUmano extends Macchinario {
	private HashSet<TipoLinkAssegnato> assegnato;
	private final int MIN_ASSEGNATO = 1;
	
	public ConUmano(String s, String ma, String mo, Data a) {
		super(s, ma, mo, a);
		assegnato = new HashSet<TipoLinkAssegnato>();
	}
	public int quantiAssegnato() {return assegnato.size();}
	public void inserisciLinkAssegnato(TipoLinkAssegnato l) {
		if (l != null && l.getConUmano() == this) 
			ManagerAssegnato.inserisci(l);
	}
	public void eliminaLinkAssegnato(TipoLinkAssegnato l) {
		if (l != null && l.getConUmano() == this)
			ManagerAssegnato.elimina(l);
	}
	public Set<TipoLinkAssegnto> getLinkAssegnato() {
		if (quantiAssegnato() < MIN_ASSEGNATO) 
			throw new RuntimeException("violata cardinalità 1..*");
		return (HashSet<TipoLinkAssegnato>) assegnato.clone();
	}
	public void inserisciPerMAnagerAssegnato(ManagerAssegnato m) {
		if (m != null) 
			assegnato.add(m.getLink());
	}
	public void eliminaPerManagerAssegnato(ManagerAssegnato m) {
		if (m != null)
			assegnato.remove(m.getLink());
	}
}
```

Associazione assegnato (responsabilità doppia, 0..1←→1..*, senza attributi) 

```jsx
public class TipoLinkAssegnato {
	private final ConUmano conum;
	private final Operatore op;

	public TipoLinkAssegnato(ConUmano c, Operatore o) {
		if (c == null || o == null)
			throw new RuntimeException("link non valido");
		conum = c;
		op = o;
	}
	public ConUmano getConUmano() {return conum;}
	public Operatore getOperatore() {return op;}
	
	public boolean equals(Object o) {
		if (o != null && getClass().equals(o.getClass())) {
			TipoLinkAssegnato l = (TipoLinkAssegnato) o;
			return l.conum == conum && l.op == op;
		}
		return false;
	}
	public int hashCode() {return conum.hashCode() + op.hashCode();}
}
```

```jsx
public final class ManagerAssegnato {
	private TipoLinkAssegnato link;
	private ManagerAssociazione(TipoLinkAssegnato l) {link = l;}
	public TipoLinkAssegnato getLink() {return link;}

	public static void inserisci(TipoLinkAssegnato l) {
		if (l != null && l.getOperatore().getLinkAssegnato() == null) {
			ManagerAssegnato m = new ManagerAssegnato(l);
			l.getConUmano().inserisciPerManagerAssegnato(m);
			l.getOperatore().inserisciPerMAnagerAssegnato(m);
		}
	}
	public static void elimina(TipoLinkAssegnato l) {
		if (l != null && l.getOperatore().getLinkAssegnato().equals(l)) {
			ManagerAssegnato m = new ManagerAssegnato(l);
			l.getConUmano().eliminaPerManagerAssegnato(m);
			l.getOperatore().eliminaPerMAnagerAssegnato(m);
		}
	}
}
```

```jsx
package Automatizzato;
import Macchinario.*;
public class Automatizzato extends Macchinario {
	Automatizzato(String s, String ma, String mo, Data a) {
		super(s, ma, mo, a);
	}
}
```

```jsx
package attivita_complesse;
public class Principale implements Runnable {
	private boolean eseguita = false;
	private Supervisore S;
	
	public Principale(Supervisore S) {this.S = S;}
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
		
		Processo processo = SegnaliIO.sceltaProcesso();
		LinkedList<TipoLinkPartecipa> ins = processo.getLinkProcesso();
		int i = 0;
		boolean continua = true;
		LinkedList<String> tot_report = new LinkedList<String>();
		
		while (i < ins.size() && continua) {
			UtilizzoMacchinario ramo1 = new UtilizzoMacchinario(ins.get(i).getMacchinario());
			Thread t1 = new Thread(ramo1);
			t1.start();
			RaccoltaStatistiche ramo2 = new RaccoltaStatistiche(ins.get(i).getMacchinario());
			Thread t2 = new Thread(ramo2);
			t2.start();
	
			try {
				t1.join();
				t2.join();
			} catch(InterruptedException e) {
				e.printStackTrace();
			}
			continua = ramo1.getResult();
			String report = ramo2.getResult();
			tot_report.add(report);
			i++;
		}
		if (!continua) {
			SegnaliIO.errore();
			return;
		}
		SegnaliIO.stampaReport(tot_report);
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```

```jsx
package attivita_complesse;
public class UtilizzoMacchinario implements Runnable {
	private boolean eseguita = false;
	private Macchinario m;
	private boolean continua;
	
	public UtilizzoMacchinario(Macchinario m) {this.m = m;}
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
	
		Verifica v = new Verifica(m);
		TaskExecutor.getInstance().perform(v);
		continua = v.getResult();
		
		if (continua) {
			AvviaMacchinario am = new AvviaMacchinario(m);
			TaskExecutor.getInstance().perform(am);
		}
	}
	public synchronized boolean estEseguita() {return eseguita;}
	public synchronized boolean getResult() {
		if (!eseguita) 
			throw new RuntimeException("attivita Utilizzo Macchinario non eseguita");
		return continua;
	}
}
```

```jsx
package attivita_complesse;
public class RaccoltaStatistiche implements Runnable {
	private boolean eseguita = false;
	private Macchinario m;
	private String result;

	public RaccoltaStatistiche(Macchinario m) {this.m = m;}
	public synchronized void run() {
		Raccolta r = new Raccolta(m);
		TaskExecutor.getInstance().perform(r);
		result = r.getResult();
	}
	public synchronized boolean estEseguita() {return eseguita;}
	public synchronized String getResult() {
		if (!eseguita)
			throw new RuntimeException("attività Raccolta Statistiche non eseguita");
		return result;
	}
}
```
