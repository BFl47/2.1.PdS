# Esame 12.7.19

**SpecificaStatiClasse** Giocatore

Stati: {RIPOSO, GIOCO}

Variabili di stato ausiliarie: -

Stato iniziale:
   statocorrente = Stato.Riposo

**SpecificaTransizioniClasse** Giocatore

Transizione: Riposo→Gioco
   sigioca(){mitt: arbitro}

Evento: SiGioca()

Condizione: -

Azione
   pre: -
   post: le posizioni di tutte le sue navi == false

Transizione: Gioco→Gioco
   colpo(coordinate)[posizione occupata]

Evento: Colpo(x: intero, y: intero)

Condizione: una delle sue navi occupa la posizione inviata come playload

Azione:
   pre: -
   post: -

Transizione: Gioco→Gioco
   colpo(coordinate)[!posizione occupata]/colpo(this.scegliCoord()){mitt: this.scegliGiocatore()}

Evento: Colpo(x: intero, y: intero)

Condizione: nessuna delle sue navi occupa la posizione inviata come playload

Azione:
   pre: -
   post: nuovoevento == colpo, con playload == this.scegliCoord() and mittente == this.scegliGiocatore();

Transizione: Gioco→Riposo
   fine() {mitt: arbitro}

Evento: Fine

Condizione: -

Azione:
   pre: -
   post: -

**FineSpecifica**

**SegnaturaAttivitaPrincipale**

AttivitaPrincipale(Gioco g) : ();

SottoAttivitaGioco(Gioco g) : ();

SottoAttivitaAnalisi(Gioco g) : (report: stringa);

**SegnaturaAttivitaAtomiche**

Verifica(insG: Insieme(Giocatore)): (ok: booleano);

AvviaGioco(Gioco g) : ();

Report(Gioco g): (report: stringa);

CalcolaVincitore(insG: Insieme(Giocatore)) : (nome: stringa);

**SegnaturaAttivitaIO**

Errore(): ();

Report(report: stringa, nome: stringa): ();

Attesa(): ();

**FineSegnatura**

```jsx
package Giocatore;
public class Giocatore implements Listener {
	private String nome;
	private TipoLinkPartecipa partecipa;
	private HashSet<Nave> navi;
	
	private final int MIN_PARTECIPA = 1;
	public int quantiPartecipa() {
		if (partecipa == null) return 0;
		return 1;
	}
	public Giocatore(String n) {
		nome = n;
		navi = new HashSet<Nave>();
	}
	public String getNome() {return nome;}
	public void inserisciLinkPartecipa(TipoLinkPartecipa l) {
		if (l != null && l.getGiocatore == this;)
			ManagerPartecipa.inserisci(l);
	}
	public void eliminaLinkPartecipa(TipoLinkPartecipa l) {
		if (l != null && l.getGiocatore == this;)
			ManagerPartecipa.elimina(l);
	}
	public TipoLinkPartecipa getLinkPartecipa() {
		if  (quantiPartecipa() == 0)
			throw new RuntimeException("violata cardinalità 1..1");
		return partecipa;
	}
	public void inserisciPerMAnagerPartecipa(ManagerPartecipa m) {
		if (m != null)
			partecipa = m.getLink();
	}
	public void eliminaPerMangerPartecipa(ManagerPartecipa m) {
		if (m != null)
			partecipa = null();
	}
	public void inserisciNave(Nave n) {
		if (n != null)
			navi.add(n);
	}
	public void eliminaNave(Nave n) {
		navi.remove(n);
	}
	public Set<Nave> getNavi() {
		return (HashSet<Nave>) navi.clone();
	}
	
	public static enum Stato = {RIPOSO, GIOCO};
	Stato statocorrente = Stato.RIPOSO;
	public Stato getStato() {return statocorrente;}
	
	public void fired(Evento e) {
		TaskExecutor.getInstance().perform(new GiocatoreFired(this, e));
	}
}
```

```jsx
package Giocatore;
class GiocatoreFired implements Task {
	private boolean eseguita = false;
	private Giocatore giocatore;
	private Evento e;
	
	public GiocatoreFired(Giocatore g, Evento e) {
		giocatore = g;
		this.e = e;
	}
	public synchronized void esegui() {
		if (eseguita || e.getDestinatario() != null && e.getDestinatario() != giocatore)
			return;
		eseguita = true;
	
		switch(giocatore.getStato()) {
			case RIPOSO:
				if (e.getClass() == SiGioca.class) {
					for (Nave n: giocatore.getNavi()) {
						if (n.getClass() == Semplice.class) {
							Semplice s = (Semplice) n;
							s.getPosizione().setColpita() = false;
						}
						else if (n.getClass() == Speciale.class) {
							Speciale sp = (Speciale)n;
							for (Posizione p: sp.getPosizioni()) 
								p.setColpita() = false;
						}
					}
					giocatore.statocorrente = Stato.GIOCO;
				}
				break;
			case GIOCO:
				if (e.getClass() == Colpo.class) {
					Colpo c = (Colpo)e;
					int x = c.getX();
					int y = c.getY();
					boolean colpita;
					for (Nave n: giocatore.getNavi()) {
						if (n.getClass() == Semplice.class) {
							Semplice s = (Semplice) n;
							if (x == s.getPosizione().getX() && y == s.getPosizione().getY()) {
								colpita = true;
								s.getPosizione().setColpita() = true;
							}					
						}
						else {
							Speciale sp = (Speciale) n;
							for (Posizione p: sp.getPosizioni()) {
								if (x == p.getX() && y == p.getY()) {
									colpita = true;
									p.setColpita() = true;
								}
							}
						}
					}
					if (!colpita) {
						Colpo colporisposta = new Colpo(giocatore, c.getMittente(), giocatore.generaX(), giocatore.generaY());
						Environment.aggiungiEvento(colporisposta);
					}
					giocatore.statocorrente = Stato.GIOCO;
				}
				else if (e.getClass() == Fine.class) 
					giocatore.statocorrente = Stato.RIPOSO;
				break;
			default: throw new RuntimeException("stato non trovato");
		}
	}
	public synchronized boolean estEseguita() {return eseguita;}
}	
```

Giocatore ha responsabilità su possiede, ma poiché è un’associazione a responsabilità singola, senza attributi, non è necessario realizzare la classe TipoLinkPossiede e il ManagerPossiede; infatti, nella classe c’è un riferimento ad un insieme di navi.

Associazione Partecipa (responsabilità doppia, 1..1 ←-→ 2..*)

```jsx
public class TipoLinkPartecipa {
	private final Giocatore giocatore;
	private final Gioco gioco;
	
	public TipoLinkPartecipa(Giocatore gc, Gioco g) {
		if (gc == null || g == null)
			throw new RuntimeException("link non valido");
		giocatore = gc;
		gioco = g;
	}
	public Giocatore getGiocatore() {return giocatore;}
	public Gioco getGioco() {return gioco;}
	
	public boolean equals(Object o) {
		if (o != null && getClass().equals(o.getClass())) {
			TipoLinkPartecipa l = (TipoLinkPartecipa) o;
			return l.giocatore == giocatore && l.gioco == gioco;
		}
		return false;
	}
	public int hashCode() {return giocatore.hashCode() + gioco.hashCode()}
}
```

```jsx
private final class ManagerPartecipa {
	private TipoLinkPartecipa link;
	private ManagerPartecipa(TipoLinkPartecipa l) {link = l;}
	public TipoLinkPartecipa getLink() {return link;}
	
	public static void inserisci(TipoLinkPartecipa l) {
		if (l != null && l.getGiocatore().quantiPartecipa == 0) {
			ManagerPartecipa m = new ManagerPartecipa(l);
			l.getGiocatore().inserisciPerManagerPartecipa(m);
			l.getGioco().inserisciPerManagerPartecipa(m);
		}
	}
	public static void elimina(TipoLinkPartecipa l) {
		if (l != null && l.getGiocaore().getLinkPartecipa().equals(l)) {
			ManagerPartecipa m = new ManagerPartecipa(l);
			l.getGiocatore().eliminaPerManagerPartecipa(m);
			l.getGioco().eliminaPerManagerPartecipa(m);
		}
	}
}
```

```jsx
package attivita_complesse;
public class AttivitaPrincipale implements Runnable {
	public boolean eseguita = false;
	private Gioco gioco;
	private TaskExecutor executor = TaskExecutor.getInstance();
	
	public AttivitaPrincipale(Gioco gioco) {gioco = g;}
	
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
		
		HashSet<Giocatore> insG = new HashSet<Giocatore>();
		for (TipoLinkPartecipa l: gioco.getLinkPartecipa())
			insG.add(l.getGiocatore());
		
		Verifica v = new Verifica(insG);
		executor.perform(v);
		boolean ok = v.getResult();
		
		if (!ok) {
			SegnaliIO.errore();
			return;
		}
		SottoAttivitaGioco ramo1 = new SottoAttivitaGioco(gioco);
		Thread t1 = new Thread(ramo1);
		t1.start();
		
		SottoAttivitaAnalisi ramo2 = new SottoAttivitaAnalisi(gioco);
		Thread t2 = new Thread(ramo2);
		t2.start();
		
		try {
			t1.join();
			t2.join();
		} catch(InterruptedException e) {
			e.printStackTrace();
		}
		String report = ramo2.getResult();
		
		CalcolaVincitore cv = new CalcolaVincitore(insG);
		executor.perform(cv);
		String nome = cv.getResult();
		
		SegnaliIO.report(report, nome);
	}
	public synchronized boolean estEseguita() {return eseguita;}
}
```

```jsx
package attivita_complesse;
public class SottoAttivitaGioca implements Runnable {
	private boolean eseguita = eseguita;
	private Gioco gioco;
	
	public SottoAttivitaGioca(Gioco g) {gioco = g;}
	
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
	
		AvviaGioco av = new AvviaGioco(gioco);
		TaskExecutor.getInstance().perform(av);
		SegnaliIO.attesa();
	}
	public synchronized void estEseguita() {return eseguita;}
}
```

```jsx
package attivita_complesse;
public class SottoAttivitaAnalisi implements Runnable {
	private boolean eseguita = eseguita;
	private Gioco gioco;
	private String result;
	
	public SottoAttivitaAnalisi(Gioco g) {gioco = g;}

	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
		
		Report r = new Report(gioco);
		TaskExecutor.getInstance().perform(r);
		result = r.getResult();
	}
	public synchronized boolean estEseguita() {return eseguita;}
	public synchronized String getResult() {
		if (!eseguita)
			throw new RuntimeException("sotto attivita analisi non eseguita");
		return result;
	}
}
```