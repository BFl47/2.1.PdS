# Esame 19.2.21

**SpecificaStatiClasse** Assassino

Stato: {RIPOSO, MISSIONE}

Variabili di stato ausiliarie:
     double t1

Stato iniziale: 
     statoiniziale = Stato.RIPOSO
     t1 = —

**FineSpecifica**

**SegnaturaAttivitaComplesse**

AttivitaPrincipale(insieme(Omicidio) insO) : ();

TentativiOmicidio(insieme(Omicidio) insO) : (insieme(Omicidio) sottoinsO);

RichiestaPagamenti(insieme(Omicidio) insO) : (double soldiRaccolti);

**SegnaturaAttivitaAtomiche**

Verifica(insieme(Omicidio) insO) : (boolean ok);

CalcolaDifferenza(insieme(Omicidio) sottoinsO, double soldiRaccolti) : (double differenza);

**SegnaturaSegnaliIO**

Stampa(double differenza) : ();

**FineSegnatura**

```jsx
public class Assassino extends Persona implements Listener {
	private String arma1;
	private HashSet<TipoLinkCommissionato> insLinkCommissionato;
	private TipoLinkMembro linkMembro;
	public static final int MIN_MEMBRO = 1;
	
	public Assassino(String n, String c, String i, String a) {
		super(n, c, i);
		arma1 = a;
		insLinkCommissionato = new HashSet<TipoLinkCommissionato>;
	}
	public int quantiMembro() {
		if (linkMembro == null) return 0;
		return 1;
	}
	public String getArma() {return arma1;}
	public void inserisciTipoLinkCommissionato(TipoLinkCommissionato l) {
		if (l != null && l.getAssassino() == this) 
			ManagerCommissionato.inserisci(l);
	}
	public void eliminaTipoLinkCommissionato(TipoLinkCommissionato l) {
		if (l != null && l.getAssassino() == this)
			ManagerCommissionato.elimina(l);
	}
	public Set<TipoLinkCommissionato> getLinkCommissionato() {
		return (HashSet<TipoLinkCommissionato>) insLinkCommissionato.clone();
	}
	public void inserisciPerManagerCommissionato(ManagerCommissionato m) {
		if (m != null)
			insLinkCommissionato.add(m.getLink());
	}
	public void eliminaPerManagerCommissionato(ManagerCommissionato m) {
		if (m != null)
			insLinkCommissionato.remove(m.getLink());
	}
	public void inserisciTipoLinkMembro(TipoLinkMembro l) {
		if (l != null && l.getAssassino() == this)
			ManagerMembro.inserisci(l);
	}
	public void eliminaTipoLinkMembro(TipoLinkMembro l) {
		if (l != null && l.getAssassino() == this)
			ManagerMembro.elimina(l);
	}
	public TipoLinkMembro getLinkMembro() {
		if (linkMembro == null)
			throw new RuntimeException("violata molteplicità 1..1");
		return linkMembro;
	}
	public void inserisciPerManagerMembro(ManagerMembro m) {
		if (m != null)
			linkMembro = m.getLink();
	}
	public void eliminaPerManagerMemebro(ManagerMembro m) {
		if (m != null)
			linkMembro = null;
	}
	
	//gestione stato
	public static enum Stato = {RIPOSO, MISSIONE};
	Stato statocorrente = Stato.RIPOSO;
	double t1;
	public Stato getStato() {return statocorrente;}
	
	//gestione transizioni
	public void fired(Evento e) {
		TaskExecutor.getInstance().perform(new AssassinoFired(this, e));
	}
}
```

```jsx
public class AssassinoFired implements Task {
	private boolean eseguita = false;
	private Assassino assassino;
	private Evento e;
	
	public AssassinoFired(Assassino a, Evento e) {
		assassino = a;
		this.e = e;
	}
	public synchronized void esegui() {
		if (eseguita || e.getDestinatario() != null && e.getDestinatario() != assassino) 
			return;
		eseguita = true;
		
		switch(assassino.getStato()):
			case RIPOSO:
				if (e.getClass().equals(Uccidi.class) {
					Uccidi u = (Uccidi) e;
					Omicidio o = u.getOmicidio();
					assassino.t1 = u.getTempoCorrente();
					assassino.inserisciLinkCommissionato(new TipoLinkCommissionato(o, assassino));
					Notifica n = new Notifica(assassino, assassino.getLinkMembro());
					Environment.addEvento(n);
					assassino.statocorrente = Stato.MISSIONE;
				}
				break;
			case MISSIONE:
				if (e.getClass().equals(Fine.class) {
					Fine f = (Fine) e;
					double t2 = f.getTempoCorrente();
					Omicidio o;
					HashSet<TipoLinkCommissionato> ins = assassino.getLinkCommissionato();
					for (TipoLinkCommissionato l: ins) {
						if (!l.getOmicidio().concluso)                                 
							o = l.getOmicidio;
					}
//quando l'assassino è in missione non può ricevere altri omicidi e resta nello stato missione 
//finchè l'omicidio corrente non si conclude, quindi per trovare l'omicidio da aggiornare
//nell'insieme dei link, bisogna cercare un link collegato all'unico omicidio non concluso
		
					o.concluso = true; 
					o.riuscito = f.getEsito();
					if(o.riuscito)
						o.getLinkCommissionato().setTempo() = assassino.t1 - t2;
					assassino.statocorrente = Stato.RIPOSO;
				}
				break;
			default: throw new RuntimeException("stato non trovato");
		}
	}
	public boolean estEseguita() {return eseguita;}
```

```jsx
public class TipoLinkCommissionato {
	private Assassino assassino;
	private Omicidio omicidio;
	private double tempo;
	
	public TipoLinkCommissionato(Assassino a, Omicidio o, double t) {
		assassino = a;
		omicidio = o;
		tempo = t;
	}
	public Assassino getAssassino() {return assassino;}
	public Omicidio getOmicidio() {return omicidio;}
	public void setTempo(double t) {tempo = t;}
	public double getTempo() {return tempo;}
	public boolean equals(Object o) {
		if (o != null && getClass().equals(o.getClass())) {
			TipoLinkCommissionato l = (TipoLinkCommissionato)o;
			return l.assassino == assassino && l.omicidio == omicidio;
		} else return false;
	}
	public int hashCode() {return assassino.hashCode() + omicidio.hashCode();}
}
```

```jsx
public final class ManagerCommissionato {
	private TipoLinkCommissionato link;
	private ManagerCommissionato(TipoLinkCommissionato l) {link = l;}
	public TipoLinkCommissionato getLinkCommissionato() {return link;}
	public static void inserisci(TipoLinkCommissionato l) {
		if (l != null && l.getOmicidio().quantiCommissionato == 0) {
			ManagerCommissionato m = new ManagerCommissionato(l);
			l.getAssassino().inserisciPerManagerCommissionato(m);
			l.getOmicidio().inserisciPerManagerCommissionato(m);
		}
	}
	public static void elimina(TipoLinkCommissionato l) {
		if (l != null && l.getOmicidio().getLinkCommissionato().equals(l)) {
			ManagerCommissionato m = new ManagerCommissionato(l);
			l.getAssassino().eliminaPerManagerCommissionato(m);
			l.getOmicidio().eliminaPerManagerCommissionato(m);
		}
	}
}
```

```jsx
public class AssassinoEsperto extends Assassino {
	private String arma2;
	public AssassinoEsperto(String n, String c, String i, String a1, String a2) {
		super(n, c, i , a1);
		arma2 = a2;
	}
	public String getArma2() {return arma2;}
}
```

```jsx
public class Persona {
	private String nome;
	private String cognome;
	private String indirizzo;
	public Persona(String n, String c, String i) {
		nome = n;
		cognome = c;
		indirizzo = i;
	}
	public String getNome() {return nome;}
	public String getCognome() {return cognome;}
	public String getIndirizzo() {return indirizzo;}
}
```

```jsx
public class TipoLinkMembro {
	private Assassino a;
	private Gilda g;
	public TipoLinkMembro(Assassino a, Gilda g) {
		this.a = a;
		this.g = g;
	}
	public Assassino getAssassino() {return a;}
	public Gilda getGilda() {return g;}
	public boolean equals(Object o) {
		if (o != null && getClass().equals(o.getClass())) {
			TipoLinkMembro l = (TipoLinkMembro) o;
			return l.a == a && l.g == g;
		} else return false;
	}
	public int hashCode() {return a.hashCode() + g.hashCode();}
}
```

```jsx
public final class ManagerMembro {
	private TipoLinkMembro link;
	private ManagerMembro(TipoLinkMembro l) {link = l;}
	public TipoLinkMembro getLink() {return link;}
	public static void inserisci(TipoLinkMembro l) {
		if (l != null && l.getAssassino().quantiMembro == 0)
			ManagerMembro m = new ManagerMembro(l);
			l.getAssassino().inserisciPerManagerMembro(m);
			l.getGilda().inserisciPerManagerMembro(m);
		}
	}
	public static void inserisci(TipoLinkMembro l) {
		if (l != null && l.getAssassino().getLinkMembro().equals(l)) {
			ManagerMembro m = new ManagerMembro(l);
			l.getAssassino().eliminaPerManagerMembro(m);
			l.getGilda().eliminaPerManagerMembro(m);
		}
	}
}
```

```jsx
public class AttivitaPrincipale implements Runnable {
	private boolean eseguita = false;
	private HashSet<Omicidio> insO;
	private TaskExecutor executor = TaskExecutor.getInstance();
	
	public AttivitaPrincipale(HashSet<Omicidio> insO) {
		this.insO = insO;
	}
	public synchronized void run() {
		if (eseguita) return;
		eseguita = true;
		
		Verifica v = new Verifica(insO);
		executor.perform(v);
		boolean ok = v.getRis();
		if (!ok) {
			SegnaliIO.errore();
			return;
		}
		TentativiOm to = new TentativiOm(insO);
		Thread t1 = new Thread(to);
		t1.start();
		RichiestaPagamenti rp = new RichiestaPagamenti(insO);
		Thread t2 = new Thread(rp);
		t2.start();
		try {
			t1.join();
			t2.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		HashSet<Omicidio> insORiusciti = to.getRis();
		double soldiRaccolti = rp.getRis();
		CalcolaDifferenza cd = new CalcolaDifferenza(insORiusciti, soldiRaccolti);
		executor.perform(cd);
		double diff = cd.getRis();
		SegnaliIO.stampa(diff);
	}
	public synchronized boolean estEseguita() {return eseguita;}
}	
```

```jsx
public class Verifica implements Task {
	private boolean eseguita = false;
	private HashSet<Omicidio> insO;
	private boolean ok = true;
	
	public Verifica(HashSet<Omicidio> insO) {
		this.insO = insO;
	}
	public synchronized void esegui() {
		if (eseguita) return;
		eseguita = true;
		
		for (Omicidio o: insO) {
			Persona committente = o.getCommittente();
			for (Omicidio om: insO) {
				if (committente.equals(om.getVittima()))
					ok = false;
			}
		}
	}
	public synchronized boolean estEseguita() {return eseguita;}
	public synchronized boolean getResult() {
		if (!eseguita)
			throw new RuntimeException("attività Verifica non eseguita");
		return ok;
	}
}
```